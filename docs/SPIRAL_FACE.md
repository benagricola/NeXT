# Spiral Facing Implementation for Rectangular and Circular Stock

## Overview

The spiral facing toolpath generator creates efficient facing operations for both circular and rectangular stock. The implementation uses a queue-based task system to sequence corner peeling, side peeling, and central spiral operations.

## Core Concepts

### Effective Machining Boundary

The **Effective Boundary** is the virtual boundary that the tool's center point must not cross during cutting moves:

```
Effective Boundary = Stock Geometry + Tool Radius + 1mm Tolerance
```

All toolpath calculations reference the tool center position relative to this boundary.

### Stock Boundary

The **Stock Boundary** represents the actual stock edges without tool compensation, used for determining which areas need peeling.

## Implementation Approach

The current implementation uses an **Outside-In** strategy with a queue-based task system.

### Supported Spiral Direction

- **`outside-in`**: ✅ Implemented (peels from outside edges toward center)
- **`inside-out`**: ❌ Not implemented (returns empty toolpath)

### Task Queue System

The toolpath is generated by processing a queue of tasks in sequence:

```typescript
type Task =
  | { type: 'corner', id: Corner }  // Corner: 'top-left' | 'top-right' | 'bottom-right' | 'bottom-left'
  | { type: 'side', id: Side }      // Side: 'left' | 'right' | 'top' | 'bottom'
  | { type: 'spiral' }              // Central spiral
```

## Rectangular Stock Sequence

The queue is built based on stock aspect ratio to minimize redundant cuts:

### Landscape Stock (stockX > stockY)

The central spiral touches the top and bottom edges first, so only left and right sides need peeling:

```
Queue:
1. Corner: top-left
2. Corner: bottom-left
3. Side: left
4. Corner: top-right
5. Corner: bottom-right
6. Side: right
7. Spiral: central spiral
```

### Portrait Stock (stockY > stockX)

The central spiral touches the left and right edges first, so only top and bottom sides need peeling:

```
Queue:
1. Corner: top-left
2. Corner: top-right
3. Side: top
4. Corner: bottom-left
5. Corner: bottom-right
6. Side: bottom
7. Spiral: central spiral
```

### Square Stock (stockX === stockY)

The central spiral touches all four sides, so only corners need peeling:

```
Queue:
1. Corner: top-left
2. Corner: top-right
3. Corner: bottom-right
4. Corner: bottom-left
5. Spiral: central spiral
```

## Circular Stock Sequence

For circular stock, only the central spiral is needed:

```
Queue:
1. Spiral: central spiral
```

## Task Processing

### Corner Peeling

**Objective**: Clear the corner area outside the central spiral's reach.

**Process**:
1. Calculate corner coordinates from the effective boundary
2. Start at the outermost radius that intersects the corner
3. For each pass (reducing radius by `effectiveWidth`):
   - Calculate arc endpoints using `calculateCornerArc()`
   - Generate arc move (G2/G3) based on milling direction
   - Use `getDogLegMove()` for transition to next pass at current Z
4. Continue until radius is too small to intersect corner boundaries

**Rapid Move Strategy**: Dog-leg moves at current Z (no Z-lift) for efficiency within the corner area.

### Side Peeling

**Objective**: Clear the side area between corners and the central spiral.

**Process**:
1. Start at the outermost radius that intersects the side
2. For each pass (reducing radius by `effectiveWidth`):
   - Calculate arc endpoints using `calculateSideArc()` or `getRobustSideArc()` (fallback for deep peeling)
   - Split arc into two segments (start→midpoint, midpoint→end) for better rendering
   - Generate arc moves (G2/G3) for each segment
   - Use `rapidTo()` with Z-lift for transition to next pass
3. Continue until radius reaches the central spiral start radius

**Rapid Move Strategy**: Z-lift to safe height between passes for safety when crossing the stock.

**Fallback Logic**: If `calculateSideArc()` fails (arc doesn't intersect boundaries), `getRobustSideArc()` generates a semi-circle as a fallback.

### Central Spiral

**Objective**: Face the remaining central area with a continuous inward spiral.

**Process**:
1. Rapid to safe height, then to spiral start position
2. Plunge to cutting depth
3. Generate continuous inward spiral using Archimedean spiral equation:
   ```
   r(θ) = r_start - (effectiveWidth / (2π)) * θ
   ```
4. Continue until center is reached (radius ≤ tool radius)

**Entry**: Uses `rapidTo()` with Z-lift for safe positioning.

## Milling Direction

The `millingDirection` parameter determines arc direction:
- **Climb milling** (`millingDirection = 1`): Clockwise arcs (G2)
- **Conventional milling** (`millingDirection = -1`): Counter-clockwise arcs (G3)

Arc start/end points are swapped based on this direction to maintain correct tool engagement.

## Helper Functions

### `getDogLegMove(from, to, centerX, centerY)`

Calculates an intermediate point for transitioning between positions without crossing the stock center. Used for corner peeling transitions.

**Logic**:
- Tests two candidates: `(from.x, to.y)` and `(to.x, from.y)`
- Selects the point furthest from center
- Returns the move sequence: `from → intermediate → to`

### `getRobustSideArc(radius, side)`

Provides fallback arc generation when `calculateSideArc()` fails (typically for deep peeling where the arc doesn't intersect stock boundaries).

**Returns**: Semi-circle endpoints for the specified side, oriented according to milling direction.

### `rapidTo(x, y, comment?)`

Generates a safe rapid move sequence:
1. Retract to safe Z height
2. Rapid to XY position
3. Plunge to current cutting depth

Includes optional comment for G-code readability.

## Append Logic

The `append()` helper ensures all meaningful moves are captured:

```typescript
const append = (p: ToolpathPoint) => {
  const last = levelPasses[levelPasses.length - 1];
  // Include point if XY OR Z has changed
  if (!last ||
      Math.hypot(p.x - last.x, p.y - last.y) > 1e-6 ||
      Math.abs(p.z - last.z) > 1e-6) {
    levelPasses.push(p);
  }
};
```

This fix ensures Z-only moves (plunges/retracts) are not filtered out.

## Z-Level Processing

The toolpath is generated for each Z-level independently:
1. Calculate Z-levels using `calculateZLevels()` (roughing + optional finishing)
2. For each level, execute the complete task queue
3. Return array of toolpath arrays (one per Z-level)

## Known Limitations

1. **Inside-Out spiral**: Not implemented (returns empty array)
2. **Finishing pass offset**: Applied uniformly to all points (not radially compensated)
3. **Arc intersection failures**: Logged to console but handled gracefully with fallbacks